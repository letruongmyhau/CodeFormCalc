*#define CHECK

#if 0
* SquaredME.F
* assembly of squared matrix element
* generated by FormCalc 9.9 (7 Jun 2021) on 30-Jul-2021 8:37
#endif

#include "specs.h"
#include "vars.h"
#include "inline.h"
#include "contains.h"


************************************************************************

	subroutine SquaredMEHel(HelInd(vmax,res), flags)
	implicit none
	SIMD_ONLY(integer vmax)
	ResType res(HelDim(*))
	integer flags

#include "vars.h"

	HelType amp
	ResType ampsq
#if DEBUG >= 3
	SIMD_ONLY(integer v)
#endif

* BEGIN ABBR_HEL
* END ABBR_HEL

	ampsq = 0
	res(HelAll(1)) = ampsq

	ampsq = 0
	TEST(flags, BIT_LOOP)
* BEGIN FF_LOOP
	Cloop(1) = 0

	call triangle

	LOOP(I2G4, 1,2,1)
	call triangle_I2G4
	ENDLOOP(I2G4)

	LOOP(I3G4, 1,3,1)
	call triangle_I3G4
	ENDLOOP(I3G4)

	LOOP(I2G5, 1,2,1)
	LOOP(I2G4, 1,2,1)
	call triangle_I2G4_I2G5
	ENDLOOP(I2G4)
	ENDLOOP(I2G5)

	LOOP(I3G5, 1,3,1)
	LOOP(I3G4, 1,3,1)
	call triangle_I3G4_I3G5
	ENDLOOP(I3G4)
	ENDLOOP(I3G5)

	LOOP(I2G6, 1,2,1)
	LOOP(I2G5, 1,2,1)
	LOOP(I2G4, 1,2,1)
	call triangle_I2G4_I2G5_I2G6
	ENDLOOP(I2G4)
	ENDLOOP(I2G5)
	ENDLOOP(I2G6)

	LOOP(I3G6, 1,3,1)
	LOOP(I3G5, 1,3,1)
	LOOP(I3G4, 1,3,1)
	call triangle_I3G4_I3G5_I3G6
	ENDLOOP(I3G4)
	ENDLOOP(I3G5)
	ENDLOOP(I3G6)

	LOOP(I9G6, 1,9,1)
	LOOP(I9G5, 1,9,1)
	LOOP(I9G4, 1,9,1)
	call triangle_I9G4_I9G5_I9G6
	ENDLOOP(I9G4)
	ENDLOOP(I9G5)
	ENDLOOP(I9G6)

	LOOP(Ind6, 1,3,1)
	LOOP(Ind5, 1,3,1)
	LOOP(Ind4, 1,3,1)
	LOOP(Ind3, 1,3,1)
	LOOP(Ind2, 1,3,1)
	LOOP(Ind1, 1,3,1)
	LOOP(I3G6, 1,3,1)
	LOOP(I3G5, 1,3,1)
	LOOP(I3G4, 1,3,1)
	call triangle_I3G4I3G5I3G6I1I2I3I4I5I6
	ENDLOOP(I3G4)
	ENDLOOP(I3G5)
	ENDLOOP(I3G6)
	ENDLOOP(Ind1)
	ENDLOOP(Ind2)
	ENDLOOP(Ind3)
	ENDLOOP(Ind4)
	ENDLOOP(Ind5)
	ENDLOOP(Ind6)
* END FF_LOOP

* BEGIN M2_LOOP
	amp = 0
	amp = amp + Cloop(1)
	ampsq = ampsq + Re(amp*Conjugate(Cloop(1)))
* END M2_LOOP
	ENDTEST(flags, BIT_LOOP)
	res(HelAll(2)) = ampsq

#if DEBUG >= 3
	print 1, HelLoop(Hel(HelInd(v,1:LEGS)), res(HelInd(v,1:2)), v,vmax)
1	format(' sqme(', LEGS I3, ') =', 2F25.12)
#endif
	end

************************************************************************

	subroutine SquaredME(result, helicities, flags)
	implicit none
	RealType result(*)
	integer*8 helicities
	integer flags

#include "vars.h"

* BEGIN VAR_DECL
	integer*8 hbits, hlast
	integer seq(2)
	save hlast, seq
	integer i, h, hmax
	parameter (hmax = 1)
	SIMD_ONLY(integer v)
	integer hsimd
	parameter (hsimd = SIMD_CEIL(hmax))
	ResType res(HelDim(2),hsimd)
	RealType rtree, rloop
	external SquaredMEHel
* END VAR_DECL

* BEGIN HSEL_DECL
	RealType norm
	RealType hseltest(0:hmax-1)
	ResType hseltest_v(HelDim(hsimd))
	equivalence (hseltest_v, hseltest)
	RealType hselmin
	integer hseli
	save hseltest, hselmin, hseli
* END HSEL_DECL


#include "inline.h"

* BEGIN SETMASS
	TEST(flags, BIT_SETMASS)
	result(1) = Masshh(i)
	result(2) = Masshh(j)
	result(3) = Masshh(k)
	return
	ENDTEST(flags, BIT_SETMASS)
* END SETMASS

* BEGIN INVARIANTS
* END INVARIANTS

	CHK_INI(seq)

	TEST(flags, BIT_RESET)
	hlast = 0
	seq(1) = seq(1) + 1
	INI_S()
* BEGIN ABBR_S
	TEST(flags, BIT_LOOP)
	call abbr1s1
	call abbr1s2
	call abbr1s3
	call abbr1s4
	call abbr1s5
	ENDTEST(flags, BIT_LOOP)
* END ABBR_S
	ENDTEST(flags, BIT_RESET)

	seq(2) = seq(2) + 1
	INI_A()
* BEGIN ABBR_ANGLE
* END ABBR_ANGLE

* BEGIN HEL_LOOP
	helicities = iand(helicities, Generic(ARG_Phel,JOIN_HEL))

	SIMD_ONLY(v = 1)
	h = 0
	do i = 0, hmax - 1
* BEGIN HSEL_IF
	  if( hseltest(i) .lt. hselmin ) cycle
* END HSEL_IF

#define hval(s,m,a,b) a*mod(i/s,m)-b

	  Hel0(1) = 0
	  Hel0(2) = 0
	  Hel0(3) = 0
#if DEBUG >= 1
	  if( helicities .ne. hlast ) print 1, ' helicities: ', Hel0
#endif
	  SIMD_ONLY(call VecCopy(v, LEGS))
	  SIMD_ONLY(v = mod(v, SIMD) + 1)
	  SIMD_ONLY(if( v .eq. 1 ) then)
	  h = h + 1
	  call SquaredMEHel(HelInd(SIMD,res(HelAll(1),h)), flags)
	  SIMD_ONLY(endif)
	enddo

	SIMD_ONLY(if( v .ne. 1 ) then)
	SIMD_ONLY(h = h + 1)
	SIMD_ONLY(call SquaredMEHel(HelInd(v,res(HelAll(1),h)), flags))
	SIMD_ONLY(endif)
	DEINI()
	SIMD_ONLY(if( v .ne. 1 ) res(v:SIMD,:,h) = 0)
* END HEL_LOOP

* BEGIN RESULT
	rtree = 0
	rloop = 0
	do i = 1, h
	  rtree = rtree + HelSum(res(HelAll(1),i))
	  rloop = rloop + HelSum(res(HelAll(2),i))
	enddo
	result(1) = rtree
	TEST(flags, BIT_LOOP)
	result(2) = rloop
	ENDTEST(flags, BIT_LOOP)

#if DEBUG >= 2
	print *, PROCNAME, ' =', rtree, rloop
#endif
* END RESULT

* BEGIN HSEL_SET
	if( helicities .ne. hlast ) then
	  hseltest = 0
	  hselmin = 0
	  hseli = 0
	endif
	if( hseli .lt. hseln .and. rtree + rloop .ne. 0 ) then
	  norm = 1/(rtree + rloop)
	  do i = 1, hsimd
	    hseltest_v(HelAll(i)) = hseltest_v(HelAll(i)) +
     &        abs(norm*(res(HelAll(1),i) + res(HelAll(2),i)))
	  enddo
	  hseli = hseli + 1
	  if( hseli .eq. hseln ) then
	    hselmin = 0
	    do i = 0, hmax - 1
	      hselmin = max(hselmin, hseltest(i))
	    enddo
	    hselmin = hselmin*hseleps
	    do i = 0, hmax - 1
	      if( hseltest(i) .ge. hselmin ) cycle
	      Hel0(1) = 0
	      Hel0(2) = 0
	      Hel0(3) = 0
	      print 1, ' neglecting ', Hel0
1	      format(A, LEGS I3)
	    enddo
	  endif
	endif
* END HSEL_SET

#ifdef CHECK
*	print *, 'tree =', rtree
	print *, 'loop =', rloop
	stop
#endif

	hlast = helicities

#include "contains.h"

	end

